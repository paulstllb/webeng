location button weg                             check
desgin änder allgeimein hintergund etc       
chatrs farbe ändern                             check
Wetter boxen ändern 


allgeimein johnnanes andrrafe weg 
404 anders





function clearCanvasfunction(context: CanvasRenderingContext2D) {
    context.fillStyle = '#fff'
    context.fillRect(0, 0, context.canvas.width, context.canvas.height)
}

//Internet
export default function CanvasDraw() {
    let canvasRef = useRef<HTMLCanvasElement>(null);

    let reset = useRef<()=>void>(function () {throw new Error()});

    function onCanvasInit() {
        const canvas = canvasRef.current!;
        const context = canvas.getContext('2d')!;
        reset.current = () => clearCanvasfunction(context);

        let rect: undefined | DOMRect;

        function updateCanvasDimension() {
            let rectnew = canvas.getBoundingClientRect();
            if(rect === undefined){
                rect = rectnew;
                canvas.width = rect.width;
                canvas.height = rect.height;
                return;
            }
            if (rectnew.width === rect.width && rectnew.height === rect.height)
                return;
            rect = rectnew;
            let old = context.getImageData(0,0,canvas.width,canvas.height);
            canvas.width = rect.width;
            canvas.height = rect.height;
            context.putImageData(old,0,0);
        }

        updateCanvasDimension();

        function getPos(e: MouseEvent) {
            let x = e.clientX - rect!.left + window.scrollX;
            let y = e.clientY - rect!.top + window.scrollY;
            return { x, y }
        }
        let pbef: { x: number, y: number } | null = null;
        canvas.onmousedown = (e) => pbef = getPos(e);
        canvas.onmouseenter = (e) => { if (pbef != null) pbef = getPos(e) };
        canvas.onmouseup = () => pbef = null;

        canvas.onmousemove = (e) => {
            if (!pbef) return;
            let pnow = getPos(e);
            context.beginPath();
            context.moveTo(pbef.x, pbef.y);
            context.lineTo(pnow.x, pnow.y);
            context.stroke();
            context.closePath();
            pbef = pnow;
        }

        let timer = setInterval(() => updateCanvasDimension(), 1000);
        return function cleanup() {
            clearInterval(timer);
        };
    }

    useEffect(onCanvasInit, [])
    return <div>
        <h1>Canvas</h1>
        <div className="vstack">
            <canvas style={{marginBottom: "10px"}} id={Styles.canvas} ref={canvasRef}></canvas>
            <div className="hstack" style={{ display: "flex", justifyContent:"space-between"}}>
                <button className={Styles.canvactionbtn} onClick={() => reset.current()}>wieder weiß</button>
                <button className={Styles.canvactionbtn} onClick={() => {
                    let data = canvasRef.current!.toDataURL('image/png');
                    let el = document.createElement("a");
                    el.href = data;
                    el.download = "image.png";
                    el.click();
                }}>runterladen</button>
                <button className={Styles.canvactionbtn} onClick={() => {
                    let data = canvasRef.current!.toDataURL('image/png');
                    var image = new Image();
                    image.src = data;
                    var w = window.open("")!;
                    w.document.write(image.outerHTML);
                }}>neuer Tab öffnen</button>
                 
            </div>
           
        </div>

    </div>
}